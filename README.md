[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=18365576&assignment_repo_type=AssignmentRepo)
# SE_Day1
Software Engineering Day1 Assignment

#Part 1: Introduction to Software Engineering

Explain what software engineering is and discuss its importance in the technology industry.
Software engineering is the application of engineering principles to create, test, modify and maintain software application involving structured methodologies,
programming languages and algorithms. Some of the importance of software engineering include enhancing efficiency and productivity by streamlining workflows 
and reducing time wastages; ensuring high quality software by reducing the risks of vulnerabilities and bugs; 
Supporting scalability and performance; Driving innovations; reducing costs and risks.

Identify and describe at least three key milestones in the evolution of software engineering.
Software engineering has grown and transformed over the years, thanks to major breakthroughs that have made software development 
more structured, efficient, and reliable. Here are three game-changing moments that helped shape the industry i.e The Birth of Software Engineering (1968) – Fixing the Chaos
Back in the 1960s, software development was a bit of a mess. Projects were running over budget, full of bugs, and often ended in failure. This problem became known as the software crisis. In 1968, a NATO conference brought together experts to figure out a solution. That’s when the term software engineering was first introduced—emphasizing that software should be built with the same careful planning and discipline as traditional engineering. This moment was the start of treating software development as a serious, structured profession rather than just trial and error.
The Rise of Structured Programming (1970s) – Making Code Easier to Manage
Early computer programs were written in a way that was difficult to read and maintain—earning the nickname spaghetti code because everything was tangled together. To fix this, structured programming became the new standard. It introduced a more organized way of writing code, breaking programs into smaller, reusable parts that made them easier to understand and update. Programming languages like C and Pascal were designed around these principles, making software development much more efficient.
3. Object-Oriented Programming (1980s-1990s) – A Smarter Way to Build Software
As software got more complex, developers needed a better way to manage their code. That’s where object-oriented programming (OOP) came in. Instead of writing endless lines of code that were hard to reuse, OOP introduced the idea of objects—self-contained units that bundle data and behavior together. This made it easier to build large applications without starting from scratch every time. Languages like C++ and later Java (1995) popularized OOP, and it’s still one of the most widely used approaches in software development today.

Other Milestones That Shaped Software Engineering
The Agile Revolution (2001): Instead of long, rigid development cycles, Agile introduced a flexible, team-driven approach, making software development faster and more adaptable.
The DevOps Movement (2010s): Development and operations teams started working more closely together, using automation and continuous delivery to speed up software deployment.
AI and Automation in Software Engineering (2020s): Artificial intelligence is now being used to help developers write, test, and debug code, making software development even faster and smarter.

List and briefly explain the phases of the Software Development Life Cycle.
Software Development Life Cycle (SDLC) is a structured process that ensures the final product is well-designed, functional, and meets user needs. 
This structured approach is called the , and it includes several key stages:
#key stages
Planning – Laying the Groundwork
Before jumping into development, teams need a clear plan. This phase involves defining the project’s goals, estimating costs, identifying risks, and mapping out a timeline. A solid plan helps avoid costly mistakes later on.

Gathering Requirements – Understanding What’s Needed
Developers work closely with stakeholders to figure out exactly what the software should do. This includes understanding user needs, system requirements, and any technical constraints. A well-documented set of requirements acts as a blueprint for the entire project.

Design – Creating the Blueprint
Once the requirements are clear, the team designs the software’s structure. This includes deciding how different components will work together, planning the user interface, and setting up databases. The goal is to ensure the system is efficient, scalable, and easy to maintain.

Development – Writing the Code
This is where the actual coding happens. Developers take the design plan and bring it to life by writing code using programming languages and frameworks. It’s one of the most time-intensive phases, but careful development ensures the software functions smoothly.

Testing – Catching Bugs Before Release
Before launching the software, it goes through multiple rounds of testing to catch any bugs, security vulnerabilities, or performance issues. Testers simulate real-world scenarios to ensure the software works as expected and is ready for users.

Deployment – Releasing the Software
Once testing is complete, it’s time to launch the software. Depending on the project, this could mean a full release to all users or a gradual rollout. The goal is to ensure a smooth transition with minimal disruptions.

Maintenance & Updates – Keeping Things Running
Even after deployment, the work isn’t over. Software requires ongoing maintenance, which includes fixing bugs, improving performance, and adding new features over time. This phase ensures the software stays relevant and continues to meet user needs.

**Compare and contrast the Waterfall and Agile methodologies. Provide examples of scenarios where each would be appropriate.**
Waterfall methodology is linear and sequential whereas Agile is iterative and flexible
In waterfall each phrase from planning to development-testing-deployment is completed before moving to the next wheras in Agile work is done in small cycles(sprints) allowing continuous feedback and improvements.
In waterfall changes are difficult to implement whereas in Agile changes are easy to incorporate to due to contionous feedback.
Waterfall is best suited for Projects with well-defined requirements and minimal expected changes whereas Agile is suited for Projects with evolving requirements and a need for quick iterations.
Waterfall works best in situations where requirements are clear and unlikely to change. Some examples include:Regulated industries – Healthcare, banking, or defense projects that require strict documentation and compliance; Infrastructure projects – Large-scale IT systems, like airport control systems, where every detail needs to be planned in advance; Manufacturing software – Factory automation systems, where changes after development can be costly.
Agile is ideal for fast-changing environments where flexibility and customer feedback are key. Some examples include: Startups and product development – When experimenting with features and adjusting based on user feedback; Mobile app development – Regular updates and new features are needed based on market trends; E-commerce platforms – Companies like Amazon constantly update their platforms based on customer behavior.

**Describe the roles and responsibilities of a Software Developer, a Quality Assurance Engineer, and a Project Manager in a software engineering team.**
 Software Developer – (The Builder) Developers write the code that brings software to life. They design features, fix bugs, and collaborate with the team to create functional, efficient programs.

Quality Assurance (QA) Engineer – (The Tester) QA engineers ensure the software is bug-free and performs well. They test features, find issues, and work with developers to fix them before release.

 Project Manager – (The Organizer) The project manager keeps everything on track—setting goals, coordinating teams, managing deadlines, and ensuring the final product meets expectations.

Developers build it, QA tests it, and the PM keeps it all running smoothly.

**Discuss the importance of Integrated Development Environments (IDEs) and Version Control Systems (VCS) in the software development process. Give examples of each.**
An IDE is a software application that provides everything a developer needs in one place, including a code editor, debugger, and compiler. It helps Speeds up development with auto-complete, syntax highlighting, and debugging tools.
Helps catch errors early with real-time feedback; Integrates with other tools like databases and VCS for smooth workflow.
i.e Visual Studio Code (VS Code) – A lightweight, flexible IDE popular for web development;IntelliJ IDEA – Great for Java development with smart coding assistance; PyCharm – Tailored for Python projects with advanced debugging features.
Version Control Systems (VCS) – A VCS helps teams track changes, collaborate, and roll back to previous versions if needed. It helps Prevents accidental data loss by saving a history of all changes.
Enables team collaboration by allowing multiple developers to work on the same project; Helps debug issues by letting developers compare versions and revert changes.
i.e Git (with GitHub, GitLab, or Bitbucket); Subversion (SVN)

**What are some common challenges faced by software engineers? Provide strategies to overcome these challenges**
Software engineers face plenty of hurdles, but with the right approach, they can stay ahead. Here are some common challenges and how to overcome them:

Debugging Bugs  –  Use debugging tools, unit tests, and code reviews to catch and fix them faster.

Keeping Up with Tech – The industry evolves fast. Staying sharp with online courses, side projects, and dev communities.

Managing Complex Projects  – Big projects can get messy. Breaking tasks into smaller steps with Agile methods, clear documentation, and team check-ins.

Balancing Speed & Quality – Rushing leads to bad code. Using automated testing, test-driven development (TDD), and clean coding practices to keep quality high.

Unclear Requirements  – Clients change their minds. Avoiding confusion by asking questions, using prototypes, and staying in constant communication.

**Explain the different types of testing (unit, integration, system, and acceptance) and their importance in software quality assurance.**
Unit Testing  – Checks individual functions or code snippets to catch small bugs early i.e Testing a login function to ensure it works with valid and invalid inputs.

 Integration Testing  – Ensures different parts of the system communicate correctly i.e Verifying that adding an item to a shopping cart updates the inventory properly.

System Testing  – Tests the entire software to ensure everything functions as expected i.e Running a full check on a banking app to confirm transactions work smoothly.

Acceptance Testing  – Makes sure the software meets user needs before launch i.e A customer testing an e-commerce site to confirm checkout works without issues.

#Part 2: Introduction to AI and Prompt Engineering
                    
**Define prompt engineering and discuss its importance in interacting with AI models.**
Prompt engineering is the practice of crafting clear, precise inputs (prompts) to guide AI models in generating accurate and useful responses. It’s like giving AI clear instructions to get the best possible answers.
Gets Better AI Responses – Well-phrased prompts lead to more accurate and helpful answers.
Saves Time – Less back-and-forth means quicker, clearer results.
Unlocks AI’s Full Potential – Whether you need help brainstorming, coding, or explaining something complex, a well-crafted prompt makes all the difference.

**Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective.**
Vague prompt: What causes a person to be sick?
Problem: Sick is a general term as there are many ilnesses and causes of ilnesses.
Improved prompt: What causes Tuberculosis and what are its symptoms?
The improved prompt is clear, specific and consise.
